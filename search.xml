<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[var、let和const的区别]]></title>
    <url>%2F2019%2F07%2F15%2Fvar%E3%80%81let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着ES6规范的到来，JavaScript中定义变量的方法已经由单一的 var 方式发展到了 var、let、const 三种之多，var众所周知，可那俩新来的哥们到底有啥新特性？到底该啥时用？ var存在的两个bug1.js没有块级作用域 通过 var 声明的变量，其作用域是函数的全部 2.循环内变量会过度共享 在循环内部定义的变量，在循环外部依旧可以访问 let存在的意义1.let声明的变量拥有块级作用域 let声明的变量其作用域只是外层块，而不是外层函数 2.let声明的全局变量不是全局对象的属性 通过let声明的全局变量无法通过window.变量名进行访问，其只存在于一个相对的作用域中 3.形如 for(let x in data) 的循环在每次迭代时都会为 x 创建新的绑定 4.let声明的变量无法重新被定义 5.let变量在声明前无法被调用 这个比较基于花括号包裹的作用域中声明了变量name ，所以JS编译器会根据ES6规定的 变量在声明之前无法使用 抛出错误 var声明的变量可以被使用是因为存在 变量提升if (true) { name = ‘abc’ // name is no defined let name} if (true) { name = ‘abc’ console.log(name) // abc var name } const的作用1.const就是用于定义常量的，常量（不会改变的变量）有以下特点 声明时必须赋值 赋值后不可以改变 1如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。 区别 var 和 let 用以声明变量，const 用于声明只读的常量； var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效； let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用； let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响； let 不允许在相同作用域内，重复声明同一个变量； const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookies，sessionStorage 和 localStorage 的区别]]></title>
    <url>%2F2019%2F07%2F11%2Fcookies%EF%BC%8CsessionStorage%20%E5%92%8C%20localStorage%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着互联网的快速发展，基于网页的应用随之增多，同时也变得越来越复杂，为了满足不同的需求会经常在本地存储大量数据，传统方式我们会用document.cookie来进行存储，但是cookie的存储大小只有4k左右，并且解析也比较复杂，每一次发送请求都需要携带cookie这样会造成带宽的浪费，给开发者带来诸多不便。 随着HTML5的到来为这些问题带来了解决方案，web存储的诞生解决了cookie存在的各种问题，web存储是将数据存储到用户的电脑上，这样可以缓解服务器的压力同时提高体验。 webstorage webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。 localStorage 1localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。 sessionStorage 1sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API： 1234567localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。localStorage.clear();​//清空localStorage中所有信息 Cookie 1生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好。 sessionStorage 、localStorage 和 cookie 之间的区别共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。]]></content>
  </entry>
</search>
