<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript中字符串对象常用方法]]></title>
    <url>%2F2019%2F07%2F18%2FJavaScript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Strong对象用于处理字符串，但作为在前端路上爬行的小鸟时常会忘记一些方法，写这篇文章的主要目的是可以方便查看和增加记忆。 数字转转字符串的方法:123let number=0; // 数字类型console.log(String(number)) // '0' 字符串console.log(new String(number)) // [String: '0'] 对象形式 静态 String.fromCharCode() 方法返回使用指定的Unicode值序 列创建的字符串。1console.log(String.fromCharCode(65,66,67)) // 'ABC' String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串。1String.fromCodePoint(65, 90); // "AZ" charAt() 方法从一个字符串中返回指定的字符。1console.log('hello'.charAt(3)) // 'l' charCodeAt() 查找字符串下标并返回unicode 值序1console.log("ABC".charCodeAt(0)) // returns 65 codePointAt() 方法返回 一个 Unicode 编码点值的非负整数。1console.log("ABC".codePointAt(0)) // returns 65 concat()方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。12let hello = 'hello';console.log(hello.concat(' word','!')); // 'hello word!'' endsWith()判断字符串结尾是否以指定的字符串结尾123456endsWith(searchString,position)searchString 为制定的字符串position 搜索截止的下标，没有填写即为字符串lengthlet str = "To be, or not to be, that is the question.";console.log( str.endsWith("question.") ); // trueconsole.log( str.endsWith("to be") ); // false includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。12console.log('Blue Whale'.includes('blue')); // false 区分大小写console.log('Blue Whale'.includes('Blue')); // true indexOf(searchValue,fromIndex) //在字符串中查找searchValue第一次出现的index，fromIndex默认为0，开始搜索的位置12console.log("Blue Whale".indexOf("Whale", 5)); // 5console.log("Blue Whale".indexOf("Whale", 12)); // -1 lastIndexOf(searchValue,fromIndex) 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -112console.log("canal".lastIndexOf("a")) // returns 3console.log("canal".lastIndexOf("a",7)) // returns 3 match() 当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。123456789var match = 'For more information, see Chapter 3.4.5.1';var re = /see (chapter \d+(\.\d)*)/i;var found = match.match(re);console.log(found); // [ 'see Chapter 3.4.5.1',// 'Chapter 3.4.5.1',// '.1',// index: 22,// input: 'For more information, see Chapter 3.4.5.1' ] es6 padEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。123console.log('abc'.padEnd(10)); // "abc " 长度为10'abc'.padEnd(10, "foo"); // "abcfoofoof" //长度为10'abc'.padEnd(6, "123456"); // "abc123" 长度为6 es6 padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。123'abc'.padStart(10); // " abc" 长度为10'abc'.padStart(10, "foo"); // "foofoofabc"'abc'.padStart(6,"123465"); // "123abc" repeat()构建并返回一个新字符串，123console.log('abcd'.repeat(2)); // abcdabcdconsole.log('abcd'.repeat(0)); // ''console.log('abcd'.repeat(3.5)); // abcdabcdabcd 小数会进行一个求余转整数 replace() 匹配元素替换1console.log('hi word'.replace('hi','hello')) // hello word search() 方法执行正则表达式和 String对象之间的一个搜索匹配。1console.log('abc'.search('b')) // 下标为1 slice(beginSlice，endSlice) 方法提取一个字符串的一部分，并返回新的字符串1console.log('abc'.slice(1,3)) // bc split();把字符串根据符号改为数组1console.log('hello word'.split('')); // [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'd' ] es6 startsWith(searchString，position) 判断字符串开始是否以指定字符串12345searchString 指定字符串position 开始的位置 默认为0let sWith='To be, or not to be, that is the question.';console.log(sWith.startsWith('To')) //trueconsole.log(sWith.startsWith('to')) //false substr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。1console.log('hello word'.substr(1,2)) // el substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。123var anyString = "Mozilla";console.log(anyString.substring(0,3)); // Mozconsole.log(anyString.substring(3,0)); // Moz toLocaleLowerCase() 字符串转换为小写1console.log('ALPHABET'.toLocaleLowerCase()); // alphabet toLocaleUpperCase() 字符串转换为大小写1console.log('alphabet'.toLocaleUpperCase()); // ALPHABET toLowerCase() 转换为小写1console.log('ALPHABET'.toLowerCase()); // alphabet toUpperCase()转换为大写1console.log('alphabet'.toUpperCase()) // ALPHABET trim()去除字符串两边的空格1console.log(' hello '.trim()); // hello valueOf() 返回一个string对象 的原始值123let string=new String('hello word');console.log(string); // [String: 'hello word']console.log(string.valueOf()); // hello word raw() 是一个模板字符串的标签函数12let name='xiaozhang';console.log(String.raw`hello $&#123;name&#125;`); // hello xiaozhang 常用的转义符号12345678910111213\0 空字符\' 单引号\" 双引号\\ 反斜杠\n 换行\r 回车\v 垂直制表符\t 水平制表符\b 退格\f 换页\uXXXX unicode 码\u&#123;X&#125; ... \u&#123;XXXXXX&#125; unicode codepoint \xXX Latin-1 字符(x小写)]]></content>
  </entry>
  <entry>
    <title><![CDATA[var、let和const的区别]]></title>
    <url>%2F2019%2F07%2F15%2Fvar%E3%80%81let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着ES6规范的到来，JavaScript中定义变量的方法已经由单一的 var 方式发展到了 var、let、const 三种之多，var众所周知，可那俩新来的哥们到底有啥新特性？到底该啥时用？ var存在的两个bug1.js没有块级作用域 通过 var 声明的变量，其作用域是函数的全部 2.循环内变量会过度共享 在循环内部定义的变量，在循环外部依旧可以访问 let存在的意义1.let声明的变量拥有块级作用域 let声明的变量其作用域只是外层块，而不是外层函数 2.let声明的全局变量不是全局对象的属性 通过let声明的全局变量无法通过window.变量名进行访问，其只存在于一个相对的作用域中 3.形如 for(let x in data) 的循环在每次迭代时都会为 x 创建新的绑定 4.let声明的变量无法重新被定义 5.let变量在声明前无法被调用 这个比较基于花括号包裹的作用域中声明了变量name ，所以JS编译器会根据ES6规定的 变量在声明之前无法使用 抛出错误 var声明的变量可以被使用是因为存在 变量提升if (true) { name = ‘abc’ // name is no defined let name} if (true) { name = ‘abc’ console.log(name) // abc var name } const的作用1.const就是用于定义常量的，常量（不会改变的变量）有以下特点 声明时必须赋值 赋值后不可以改变 1如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。 区别 var 和 let 用以声明变量，const 用于声明只读的常量； var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效； let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用； let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响； let 不允许在相同作用域内，重复声明同一个变量； const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookies，sessionStorage 和 localStorage 的区别]]></title>
    <url>%2F2019%2F07%2F11%2Fcookies%EF%BC%8CsessionStorage%20%E5%92%8C%20localStorage%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着互联网的快速发展，基于网页的应用随之增多，同时也变得越来越复杂，为了满足不同的需求会经常在本地存储大量数据，传统方式我们会用document.cookie来进行存储，但是cookie的存储大小只有4k左右，并且解析也比较复杂，每一次发送请求都需要携带cookie这样会造成带宽的浪费，给开发者带来诸多不便。 随着HTML5的到来为这些问题带来了解决方案，web存储的诞生解决了cookie存在的各种问题，web存储是将数据存储到用户的电脑上，这样可以缓解服务器的压力同时提高体验。 webstorage webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。 localStorage 1localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。 sessionStorage 1sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API： 1234567localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。localStorage.clear();​//清空localStorage中所有信息 Cookie 1生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好。 sessionStorage 、localStorage 和 cookie 之间的区别共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。]]></content>
  </entry>
</search>
