<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript干货收藏]]></title>
    <url>%2F2019%2F07%2F25%2FJavaScript%E5%B9%B2%E8%B4%A7%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[网上无意发现一篇好文，对于目前常见的面试题，实现了相应方法的核心原理。 特此码住收藏！ 1. 实现一个call函数123456789101112// 将要改变this指向的方法挂到目标this上执行并返回Function.prototype.mycall = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let arg = [...arguments].slice(1) let result = context.fn(...arg) delete context.fn return result&#125; 2. 实现一个apply函数123456789101112131415Function.prototype.myapply = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 3. 实现一个bind函数123456789101112131415Function.prototype.mybind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; let _this = this let arg = [...arguments].slice(1) return function F() &#123; // 处理函数使用new的情况 if (this instanceof F) &#123; return new _this(...arg, ...arguments) &#125; else &#123; return _this.apply(context, arg.concat(...arguments)) &#125; &#125;&#125; 4. instanceof的原理1234567891011121314// 右边变量的原型存在于左边变量的原型链上function instanceOf(left, right) &#123; let leftValue = left.__proto__ let rightValue = right.prototype while (true) &#123; if (leftValue === null) &#123; return false &#125; if (leftValue === right) &#123; return true &#125; leftValue = rightValue.__proto__ &#125;&#125; 5. Object.create的基本实现原理1234function create(obj) &#123; function F() &#123;&#125; F.prototype = obj return new F() 6. new本质123456789101112131415161718function myNew (fun) &#123; return function () &#123; // 创建一个新对象且将其隐式原型指向构造函数原型 let obj = &#123; __proto__ : fun.prototype &#125; // 执行构造函数 fun.call(obj, ...arguments) // 返回该对象 return obj &#125;&#125;function person(name, age) &#123; this.name = name this.age = age&#125;let obj = myNew(person)('chen', 18) // &#123;name: "chen", age: 18&#125; 7. 实现一个基本的Promise123456789101112131415161718192021222324252627282930313233343536373839// ①自动执行函数，②三个状态，③thenclass Promise &#123; constructor (fn) &#123; // 三个状态 this.state = 'pending' this.value = undefined this.reason = undefined let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled' this.value = value &#125; &#125; let reject = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected' this.reason = value &#125; &#125; // 自动执行函数 try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125; // then then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case 'fulfilled': onFulfilled() break case 'rejected': onRejected() break default: &#125; &#125;&#125; 8. 实现浅拷贝123456// 1. ...实现let copy1 = &#123;...&#123;x:1&#125;&#125;// 2. Object.assign实现let copy2 = Object.assign(&#123;&#125;, &#123;x:1&#125;) 9. 实现一个基本的深拷贝1234567891011121314// 1. JOSN.stringify()/JSON.parse()let obj = &#123;a: 1, b: &#123;x: 3&#125;&#125;JSON.parse(JSON.stringify(obj))// 2. 递归拷贝function deepClone(obj) &#123; let copy = obj instanceof Array ? [] : &#123;&#125; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i] &#125; &#125; return copy&#125; 10. 使用setTimeout模拟setInterval12345// 可避免setInterval因执行时间导致的间隔执行时间不一致setTimeout (function () &#123; // do something setTimeout (arguments.callee, 500)&#125;, 500) 11. js实现一个继承方法// 借用构造函数继承实例属性123456789function Child () &#123; Parent.call(this)&#125;// 寄生继承原型属性(function () &#123; let Super = function () &#123;&#125; Super.prototype = Parent.prototype Child.prototype = new Super()&#125;)() 12. 实现一个基本的Event Bus123456789101112131415161718192021222324252627// 组件通信，一个触发与监听的过程class EventEmitter &#123; constructor () &#123; // 存储事件 this.events = this.events || new Map() &#125; // 监听事件 addListener (type, fn) &#123; if (!this.events.get(type)) &#123; this.events.set(type, fn) &#125; &#125; // 触发事件 emit (type) &#123; let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) &#125;&#125;// 测试let emitter = new EventEmitter()// 监听事件emitter.addListener('ages', age =&gt; &#123; console.log(age)&#125;)// 触发事件emitter.emit('ages', 18) // 18 13. 实现一个双向数据绑定12345678910111213141516171819let obj = &#123;&#125;let input = document.getElementById('input')let span = document.getElementById('span')Object.defineProperty(obj, 'text', &#123; configurable: true, enumerable: true, get() &#123; console.log('获取数据了') return obj.text &#125;, set(newVal) &#123; console.log('数据更新了') input.value = newVal span.innerHTML = newVal &#125;&#125;)input.addEventListener('keyup', function(e) &#123; obj.text = e.target.value&#125;) 14. 实现一个简单路由12345678910111213141516171819202122class Route&#123; constructor()&#123; // 路由存储对象 this.routes = &#123;&#125; // 当前hash this.currentHash = '' // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener('load', this.freshRoute, false) window.addEventListener('hashchange', this.freshRoute, false) &#125; // 存储 storeRoute (path, cb) &#123; this.routes[path] = cb || function () &#123;&#125; &#125; // 更新 freshRoute () &#123; this.currentHash = location.hash.slice(1) || '/' this.routes[this.currentHash]() &#125;&#125; 15. 实现懒加载123456789101112&lt;ul&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/1.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/2.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/3.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/4.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/5.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/6.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/7.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/8.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/9.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/10.png" alt=""&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516let imgs = document.querySelectorAll('img')// 可视区高度let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeightfunction lazyLoad () &#123; // 滚动卷去的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop for (let i = 0; i &lt; imgs.length; i ++) &#123; // 得到图片顶部距离可视区顶部的距离 let x = clientHeight + scrollTop - imgs[i].offsetTop // 图片在可视区内 if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123; imgs[i].src = imgs[i].getAttribute('data') &#125; &#125;&#125;setInterval(lazyLoad, 1000) 16. rem实现原理1234567function setRem () &#123; let doc = document.documentElement let width = doc.getBoundingClientRect().width // 假设设计稿为宽750，则rem为10px let rem = width / 75 doc.style.fontSize = rem + 'px'&#125; 17. 手写实现AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 1. 简单实现// 实例化let xhr = new XMLHttpRequest()// 初始化xhr.open(method, url, async)// 发送请求xhr.send(data)// 设置状态变化回调处理请求结果xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 2. 基于promise实现function ajax (options) &#123; // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || 'get' // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; // 返回一个Promise实例 return new Promise ((resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject('请求超时') // 监听状态变化回调 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; // 错误回调 xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key])) &#125; encodeData = paramArr.join('&amp;') &#125; // get请求拼接参数 if (method === 'get') &#123; // 检测url中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&amp;' // 拼接url url += encodeData &#125; // 初始化 xhr.open(method, url, async) // 发送请求 if (method === 'get') xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) &#125; &#125;)&#125; 18. 实现拖拽1234567891011121314151617181920212223242526272829303132window.onload = function () &#123; // drag处于绝对定位状态 let drag = document.getElementById('box') drag.onmousedown = function(e) &#123; var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) &#123; // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left &lt; 0) &#123; left = 0 &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123; left = window.innerWidth - drag.offsetWidth &#125; if (top &lt; 0) &#123; top = 0 &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123; top = window.innerHeight - drag.offsetHeight &#125; drag.style.left = left + 'px' drag.style.top = top + 'px' &#125; drag.onmouseup = function (e) &#123; this.onmousemove = null this.onmouseup = null &#125; &#125;&#125; 19. 实现一个节流函数123456789101112131415161718function throttle (fn, delay) &#123; // 利用闭包保存时间 let prev = Date.now() return function () &#123; let context = this let arg = arguments let now = Date.now() if (now - prev &gt;= delay) &#123; fn.apply(context, arg) prev = Date.now() &#125; &#125;&#125;function fn () &#123; console.log('节流')&#125;addEventListener('scroll', throttle(fn, 1000)) 20. 实现一个防抖函数123456789101112131415161718function debounce (fn, delay) &#123; // 利用闭包保存定时器 let timer = null return function () &#123; let context = this let arg = arguments // 在规定时间内再次触发会先清除定时器后再重设定时器 clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(context, arg) &#125;, delay) &#125;&#125;function fn () &#123; console.log('防抖')&#125;addEventListener('scroll', debounce(fn, 1000)) 作者：陈煜仑 https://juejin.im/post/5d2ee123e51d4577614761f8]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中数组对象常用方法]]></title>
    <url>%2F2019%2F07%2F19%2FJavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目的很简单，主要回顾下javascript里面Array常用的一些属性以及方法，虽然经常使用，但其实一些细节没有注意到，总是等到用到的时候再去查有点浪费时间，因此总结了下加深印象 不改变原数组的方法：1.indexOf() 和lastIndexOf() 1.1 indexOf() : 返回元素在数组的索引，从0开始。若数组不存在该元素，则返回-1。 123var arr = [1, 2];arr.indexOf(1); // 0arr.indexOf(10); // -1 1.2 lastIndexOf(): 返回元素在数组中最后一次出现的索引，如果没有出现则返回-1. 12var arr = [1, 2, 3, 4, 2];arr.lastIndexOf(2); // 4 2.slice(): 与字符串的substring()方法一样，截取数组的一部分，返回一个新的数组。 2.1 通常，接受2个参数作为一个左闭右开区间，即包括开始索引位置的元素，但不包括结束索引位置的元素。 12var arr = [1, 2, 3,4,5,6];arr.slice(0,2) // [1, 2] 只返回索引0,1位置的元素 2.2 可以省略第二个参数，即截取到原数组的最后一个元素。 1arr.slice(2,); // [3, 4, 5, 6] 2.3 如果没有传参数，则返回一个从头到尾截取所有元素的新数组。可以用来复制一个数组。 12var copyArr = arr.slice();copyArr; // [1, 2, 3, 4, 5, 6] 3.concat(): 合并数组。把当前的数组和另一个数组连接起来，并返回一个新的数组。 3.1 concat()方法的参数可以有多个，也可以任意任意类型，数值、字符串、布尔值、数组、对象 都可以，参数会被被添加到新的数组中。 1234var arr1 = [1, 2, 3,4,5,6];var arr2 = ['a','b','c'];var arr3 = arr1.concat(arr2);arr3; // [1, 2, 3, 4, 5, 6, "a", "b", "c"] 3.2 注意，如果参数是数组, 会被拉平一次，即数组会被拆开来，加入到新的数组中。具体看示例： 123var arr1 = [1, 2, 3];var arr2 = arr1.concat(66,'abc',true,[10,20],[30,[31,32]],&#123;x:100&#125;);arr2; // [1, 2, 3, 66, "abc", true, 10, 20, 30, [31,32], &#123;x:100&#125;] 4.join(): 转成字符串。它会把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。 4.1 参数是用来指定连接的字符串。见示例代码： 12var arr = [1, 2, 3];arr.join('*') // "1*2*3" 4.2 如果没有指定参数，默认是用,连接。 12var arr = [1, 2, 3];arr.join() // "1,2,3" 5.toString(): 返回数组的字符串形式 12var arr = [1, 2, 3];arr.toString() // "1,2,3" 6.valueOf():返回数组本身 12var arr = [1, 2, 3];arr.valueOf() // [1, 2, 3] 7.map(): 7.1 对数组的所有成员依次调用一个函数，返回值是一个新数组。 123456var arr = [1, 2, 3];arr.map(function(elem)&#123; return elem*2;&#125;);// [2, 4, 6, 8]arr; // [1, 2, 3] 7.2 map方法接受一个函数作为参数,该函数调用时，map方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。 1234javascriptarr.map(function(elem, index, arr) &#123; return elem * index;&#125;); // [0, 2, 6] 7.3 map方法还可以接受第2个参数，表示回调函数执行时this所指向的对象。 8.forEach(): 与map方法很相似，也是遍历数组的所有成员，执行某种操作。注意：forEach方法一般没有返回值 12345678var arr = [1, 2, 3];function log(element, index, array) &#123; console.log('[' + index + '] = ' + element);&#125;arr.forEach(log);// [0] = 1// [1] = 2// [2] = 3 注意: forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 9.filter(): 9.1 筛选数组的元素，返回值是符合筛选条件元素组成的一个新数组。 12345var arr = [1, 2, 3, 4, 5];arr.filter(function (elem) &#123; return (elem &gt; 3);&#125;);// [4, 5] 9.2 filter方法接受一个函数作为参数,该函数调用时，fitler方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。 12345var arr = [1, 2, 3, 4, 5];arr.filter(function (elem, index, arr) &#123; return index % 2 === 1;&#125;);// [2, 4] 9.3 filter方法还可以接受第2个参数，指定测试函数所在的上下文对象（即this对象）。 10.some()和every(): 类似“断言”（assert），用来判断数组成员是否符合某种条件。 10.1 接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。 10.2 some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 12345var arr = [1, 2, 3, 4];arr.some(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// true 10.3 every方法则是所有数组成员的返回值都是true，才返回true，否则false。 12345var arr = [1, 2, 3, 4];arr.every(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// false 10.4 注意，对于空数组，some方法返回false，every方法返回true 10.5 some和every方法还可以接受第2个参数，用来绑定函数中的this关键字。 11.reduce()和reduceRight(): 依次处理数组的每个成员，最终累计为一个值。 11.1reduce是从左到右处理（从第一个成员到最后一个成员） 1234567arr.reduce(function(x, y)&#123; console.log(x, y) return x + y;&#125;);// 1 2// 3 3// 6 11.2reduceRight则是从右到左处理（从最后一个成员到第一个成员） 1234567arr.reduceRight(function(x, y)&#123; console.log(x, y) return x + y;&#125;);// 3 2// 5 1// 6 改变原数组的方法：1.push(): 向数组的末尾添加若干元素。返回值是改变后的数组长度。 1234567var arr = [1, 2];arr.push(3) ;// 3arr; // [1, 2, 3]arr.push('b','c'); //5arr; // [1, 2, 3, "b", "c"]arr.push([10,20]); //6arr; // [1, 2, 3, "b", "c", [10,20]] 2.pop(): 删除数组最后一个元素。返回值是删除的元素。 123var arr =[1, 2, 3, "b", "c", [10,20]];arr.pop(); // [10, 20]arr; // [1, 2, 3, "b", "c"] 3.unshift(): 向数组头部添加若干元素。返回值是改变后的数组长度。 123var arr = [1, 2];arr.unshift(3,4 ); // 4arr; // [3, 4, 1, 2] 4.shift(): 删除数组最后一个元素。返回值是删除的元素。 123var arr = ['a', 'b', 1, 2];arr.shift(); // 'a'arr; // ['b', 1, 2] 5.sort(): 数组排序。 5.1 注意：默认是将所有元素转换成字符串，再按字符串Unicode码点排序。返回值是新的数组。 12var arr = [1, 2, 12, 'a', 'b', 'ab', 'A', 'B']arr.sort(); // [1, 12, 2, "A", "B", "a", "ab", "b"] 注意：12排在了2的前面 5.2 如果元素都是数字，要按从小到大排序，可以传入一个回调函数作为参数。 123456var arr = [1, 2, 12, 100]arr.sort(function(a,b)&#123; return a-b;&#125;);// [1, 2, 12, 100] 5.3 如果想要从大到小排序： 1234arr.sort(function(a,b)&#123; return b-a;&#125;);// [100, 12, 2, 1] 6.reverse(): 颠倒数组中元素的位置 123var arr = [1, 2, 12, 'a', 'b', 'ab', 'A', 'B'];arr.reverse();// ["B", "A", "ab", "b", "a", 12, 2, 1] 7.splice(): 修改数组元素（新增、删减、替换）。从指定的索引开始删除若干个元素，然后再从该位置添加若干个元素。返回值是删除的元素组成的数组。参数1是删除元素的起始索引，参数2是删除的元素个数，之后的参数为待添加的元素。 7.1 只删除,不添加。可以传入2个参数： 12345var arr = ['Alibaba', 'Tencent', 'Baidu', 'XiaoMi', '360'];// 从索引2开始删除3个元素arr.splice(2, 3); // 返回删除的元素 ['Baidu', 'XiaoMi', '360']arr; // ['Alibaba', 'Tencent'] 7.2 只添加,不删除。第2个参数设为0，即不删除元素。 12arr.splice(2, 0, 'Toutiao', 'Meituan', 'Didi'); // 返回[],因为没有删除任何元素arr; // ["Alibaba", "Tencent", "Toutiao", "Meituan", "Didi"] 7.3 先删除若干元素，然后在删除的位置上在添加若干个元素。 123var arr =["Alibaba", "Tencent", "Toutiao", "Meituan", "Didi"]arr.splice(2,2,'Apple','Google'); // ["Toutiao", "Meituan"]arr; // ["Alibaba", "Tencent", "Apple", "Google", "Didi"] Array.isArray()用来判断一个值是否为数组, 如果参数为数组，返回true，否则，返回false. 1234var arr = [1,2]Array.isArray(arr); // true;Array.isArray('a'); // false]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中字符串对象常用方法]]></title>
    <url>%2F2019%2F07%2F18%2FJavaScript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Strong对象用于处理字符串，但作为在前端路上爬行的小鸟时常会忘记一些方法，写这篇文章的主要目的是可以方便查看和增加记忆。 数字转转字符串的方法:123let number=0; // 数字类型console.log(String(number)) // '0' 字符串console.log(new String(number)) // [String: '0'] 对象形式 静态 String.fromCharCode() 方法返回使用指定的Unicode值序 列创建的字符串。1console.log(String.fromCharCode(65,66,67)) // 'ABC' String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串。1String.fromCodePoint(65, 90); // "AZ" charAt() 方法从一个字符串中返回指定的字符。1console.log('hello'.charAt(3)) // 'l' charCodeAt() 查找字符串下标并返回unicode 值序1console.log("ABC".charCodeAt(0)) // returns 65 codePointAt() 方法返回 一个 Unicode 编码点值的非负整数。1console.log("ABC".codePointAt(0)) // returns 65 concat()方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。12let hello = 'hello';console.log(hello.concat(' word','!')); // 'hello word!'' endsWith()判断字符串结尾是否以指定的字符串结尾123456endsWith(searchString,position)searchString 为制定的字符串position 搜索截止的下标，没有填写即为字符串lengthlet str = "To be, or not to be, that is the question.";console.log( str.endsWith("question.") ); // trueconsole.log( str.endsWith("to be") ); // false includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。12console.log('Blue Whale'.includes('blue')); // false 区分大小写console.log('Blue Whale'.includes('Blue')); // true indexOf(searchValue,fromIndex) //在字符串中查找searchValue第一次出现的index，fromIndex默认为0，开始搜索的位置12console.log("Blue Whale".indexOf("Whale", 5)); // 5console.log("Blue Whale".indexOf("Whale", 12)); // -1 lastIndexOf(searchValue,fromIndex) 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -112console.log("canal".lastIndexOf("a")) // returns 3console.log("canal".lastIndexOf("a",7)) // returns 3 match() 当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。123456789var match = 'For more information, see Chapter 3.4.5.1';var re = /see (chapter \d+(\.\d)*)/i;var found = match.match(re);console.log(found); // [ 'see Chapter 3.4.5.1',// 'Chapter 3.4.5.1',// '.1',// index: 22,// input: 'For more information, see Chapter 3.4.5.1' ] es6 padEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。123console.log('abc'.padEnd(10)); // "abc " 长度为10'abc'.padEnd(10, "foo"); // "abcfoofoof" //长度为10'abc'.padEnd(6, "123456"); // "abc123" 长度为6 es6 padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。123'abc'.padStart(10); // " abc" 长度为10'abc'.padStart(10, "foo"); // "foofoofabc"'abc'.padStart(6,"123465"); // "123abc" repeat()构建并返回一个新字符串，123console.log('abcd'.repeat(2)); // abcdabcdconsole.log('abcd'.repeat(0)); // ''console.log('abcd'.repeat(3.5)); // abcdabcdabcd 小数会进行一个求余转整数 replace() 匹配元素替换1console.log('hi word'.replace('hi','hello')) // hello word search() 方法执行正则表达式和 String对象之间的一个搜索匹配。1console.log('abc'.search('b')) // 下标为1 slice(beginSlice，endSlice) 方法提取一个字符串的一部分，并返回新的字符串1console.log('abc'.slice(1,3)) // bc split();把字符串根据符号改为数组1console.log('hello word'.split('')); // [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'd' ] es6 startsWith(searchString，position) 判断字符串开始是否以指定字符串12345searchString 指定字符串position 开始的位置 默认为0let sWith='To be, or not to be, that is the question.';console.log(sWith.startsWith('To')) //trueconsole.log(sWith.startsWith('to')) //false substr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。1console.log('hello word'.substr(1,2)) // el substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。123var anyString = "Mozilla";console.log(anyString.substring(0,3)); // Mozconsole.log(anyString.substring(3,0)); // Moz toLocaleLowerCase() 字符串转换为小写1console.log('ALPHABET'.toLocaleLowerCase()); // alphabet toLocaleUpperCase() 字符串转换为大小写1console.log('alphabet'.toLocaleUpperCase()); // ALPHABET toLowerCase() 转换为小写1console.log('ALPHABET'.toLowerCase()); // alphabet toUpperCase()转换为大写1console.log('alphabet'.toUpperCase()) // ALPHABET trim()去除字符串两边的空格1console.log(' hello '.trim()); // hello valueOf() 返回一个string对象 的原始值123let string=new String('hello word');console.log(string); // [String: 'hello word']console.log(string.valueOf()); // hello word raw() 是一个模板字符串的标签函数12let name='xiaozhang';console.log(String.raw`hello $&#123;name&#125;`); // hello xiaozhang 常用的转义符号12345678910111213\0 空字符\' 单引号\" 双引号\\ 反斜杠\n 换行\r 回车\v 垂直制表符\t 水平制表符\b 退格\f 换页\uXXXX unicode 码\u&#123;X&#125; ... \u&#123;XXXXXX&#125; unicode codepoint \xXX Latin-1 字符(x小写)]]></content>
  </entry>
  <entry>
    <title><![CDATA[var、let和const的区别]]></title>
    <url>%2F2019%2F07%2F15%2Fvar%E3%80%81let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着ES6规范的到来，JavaScript中定义变量的方法已经由单一的 var 方式发展到了 var、let、const 三种之多，var众所周知，可那俩新来的哥们到底有啥新特性？到底该啥时用？ var存在的两个bug1.js没有块级作用域 通过 var 声明的变量，其作用域是函数的全部 2.循环内变量会过度共享 在循环内部定义的变量，在循环外部依旧可以访问 let存在的意义1.let声明的变量拥有块级作用域 let声明的变量其作用域只是外层块，而不是外层函数 2.let声明的全局变量不是全局对象的属性 通过let声明的全局变量无法通过window.变量名进行访问，其只存在于一个相对的作用域中 3.形如 for(let x in data) 的循环在每次迭代时都会为 x 创建新的绑定 4.let声明的变量无法重新被定义 5.let变量在声明前无法被调用 这个比较基于花括号包裹的作用域中声明了变量name ，所以JS编译器会根据ES6规定的 变量在声明之前无法使用 抛出错误 var声明的变量可以被使用是因为存在 变量提升if (true) { name = ‘abc’ // name is no defined let name} if (true) { name = ‘abc’ console.log(name) // abc var name } const的作用1.const就是用于定义常量的，常量（不会改变的变量）有以下特点 声明时必须赋值 赋值后不可以改变 1如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。 区别 var 和 let 用以声明变量，const 用于声明只读的常量； var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效； let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用； let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响； let 不允许在相同作用域内，重复声明同一个变量； const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookies，sessionStorage 和 localStorage 的区别]]></title>
    <url>%2F2019%2F07%2F11%2Fcookies%EF%BC%8CsessionStorage%20%E5%92%8C%20localStorage%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着互联网的快速发展，基于网页的应用随之增多，同时也变得越来越复杂，为了满足不同的需求会经常在本地存储大量数据，传统方式我们会用document.cookie来进行存储，但是cookie的存储大小只有4k左右，并且解析也比较复杂，每一次发送请求都需要携带cookie这样会造成带宽的浪费，给开发者带来诸多不便。 随着HTML5的到来为这些问题带来了解决方案，web存储的诞生解决了cookie存在的各种问题，web存储是将数据存储到用户的电脑上，这样可以缓解服务器的压力同时提高体验。 webstorage webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。 localStorage 1localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。 sessionStorage 1sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API： 1234567localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。localStorage.clear();​//清空localStorage中所有信息 Cookie 1生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好。 sessionStorage 、localStorage 和 cookie 之间的区别共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。]]></content>
  </entry>
</search>
