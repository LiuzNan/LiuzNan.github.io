<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript中数组对象常用方法]]></title>
    <url>%2F2019%2F07%2F19%2FJavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[不改变原数组的方法：1.indexOf() 和lastIndexOf() 1.1 indexOf() : 返回元素在数组的索引，从0开始。若数组不存在该元素，则返回-1。 123var arr = [1, 2];arr.indexOf(1); // 0arr.indexOf(10); // -1 1.2 lastIndexOf(): 返回元素在数组中最后一次出现的索引，如果没有出现则返回-1. 12var arr = [1, 2, 3, 4, 2];arr.lastIndexOf(2); // 4 2.slice(): 与字符串的substring()方法一样，截取数组的一部分，返回一个新的数组。 2.1 通常，接受2个参数作为一个左闭右开区间，即包括开始索引位置的元素，但不包括结束索引位置的元素。 12var arr = [1, 2, 3,4,5,6];arr.slice(0,2) // [1, 2] 只返回索引0,1位置的元素 2.2 可以省略第二个参数，即截取到原数组的最后一个元素。 1arr.slice(2,); // [3, 4, 5, 6] 2.3 如果没有传参数，则返回一个从头到尾截取所有元素的新数组。可以用来复制一个数组。 12var copyArr = arr.slice();copyArr; // [1, 2, 3, 4, 5, 6] 3.concat(): 合并数组。把当前的数组和另一个数组连接起来，并返回一个新的数组。 3.1 concat()方法的参数可以有多个，也可以任意任意类型，数值、字符串、布尔值、数组、对象 都可以，参数会被被添加到新的数组中。 1234var arr1 = [1, 2, 3,4,5,6];var arr2 = ['a','b','c'];var arr3 = arr1.concat(arr2);arr3; // [1, 2, 3, 4, 5, 6, "a", "b", "c"] 3.2 注意，如果参数是数组, 会被拉平一次，即数组会被拆开来，加入到新的数组中。具体看示例： 123var arr1 = [1, 2, 3];var arr2 = arr1.concat(66,'abc',true,[10,20],[30,[31,32]],&#123;x:100&#125;);arr2; // [1, 2, 3, 66, "abc", true, 10, 20, 30, [31,32], &#123;x:100&#125;] 4.join(): 转成字符串。它会把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。 4.1 参数是用来指定连接的字符串。见示例代码： 12var arr = [1, 2, 3];arr.join('*') // "1*2*3" 4.2 如果没有指定参数，默认是用,连接。 12var arr = [1, 2, 3];arr.join() // "1,2,3" 5.toString(): 返回数组的字符串形式 12var arr = [1, 2, 3];arr.toString() // "1,2,3" 6.valueOf():返回数组本身 12var arr = [1, 2, 3];arr.valueOf() // [1, 2, 3] 7.map(): 7.1 对数组的所有成员依次调用一个函数，返回值是一个新数组。 123456var arr = [1, 2, 3];arr.map(function(elem)&#123; return elem*2;&#125;);// [2, 4, 6, 8]arr; // [1, 2, 3] 7.2 map方法接受一个函数作为参数,该函数调用时，map方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。 1234javascriptarr.map(function(elem, index, arr) &#123; return elem * index;&#125;); // [0, 2, 6] 7.3 map方法还可以接受第2个参数，表示回调函数执行时this所指向的对象。 8.forEach(): 与map方法很相似，也是遍历数组的所有成员，执行某种操作。注意：forEach方法一般没有返回值 12345678var arr = [1, 2, 3];function log(element, index, array) &#123; console.log('[' + index + '] = ' + element);&#125;arr.forEach(log);// [0] = 1// [1] = 2// [2] = 3 注意: forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 9.filter(): 9.1 筛选数组的元素，返回值是符合筛选条件元素组成的一个新数组。 12345var arr = [1, 2, 3, 4, 5];arr.filter(function (elem) &#123; return (elem &gt; 3);&#125;);// [4, 5] 9.2 filter方法接受一个函数作为参数,该函数调用时，fitler方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。 12345var arr = [1, 2, 3, 4, 5];arr.filter(function (elem, index, arr) &#123; return index % 2 === 1;&#125;);// [2, 4] 9.3 filter方法还可以接受第2个参数，指定测试函数所在的上下文对象（即this对象）。 10.some()和every(): 类似“断言”（assert），用来判断数组成员是否符合某种条件。 10.1 接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。 10.2 some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 12345var arr = [1, 2, 3, 4];arr.some(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// true 10.3 every方法则是所有数组成员的返回值都是true，才返回true，否则false。 12345var arr = [1, 2, 3, 4];arr.every(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// false 10.4 注意，对于空数组，some方法返回false，every方法返回true 10.5 some和every方法还可以接受第2个参数，用来绑定函数中的this关键字。 11.reduce()和reduceRight(): 依次处理数组的每个成员，最终累计为一个值。 11.1reduce是从左到右处理（从第一个成员到最后一个成员） 1234567arr.reduce(function(x, y)&#123; console.log(x, y) return x + y;&#125;);// 1 2// 3 3// 6 11.2reduceRight则是从右到左处理（从最后一个成员到第一个成员） 1234567arr.reduceRight(function(x, y)&#123; console.log(x, y) return x + y;&#125;);// 3 2// 5 1// 6 改变原数组的方法：1.push(): 向数组的末尾添加若干元素。返回值是改变后的数组长度。 1234567var arr = [1, 2];arr.push(3) ;// 3arr; // [1, 2, 3]arr.push('b','c'); //5arr; // [1, 2, 3, "b", "c"]arr.push([10,20]); //6arr; // [1, 2, 3, "b", "c", [10,20]] 2.pop(): 删除数组最后一个元素。返回值是删除的元素。 123var arr =[1, 2, 3, "b", "c", [10,20]];arr.pop(); // [10, 20]arr; // [1, 2, 3, "b", "c"] 3.unshift(): 向数组头部添加若干元素。返回值是改变后的数组长度。 123var arr = [1, 2];arr.unshift(3,4 ); // 4arr; // [3, 4, 1, 2] 4.shift(): 删除数组最后一个元素。返回值是删除的元素。 123var arr = ['a', 'b', 1, 2];arr.shift(); // 'a'arr; // ['b', 1, 2] 5.sort(): 数组排序。 5.1 注意：默认是将所有元素转换成字符串，再按字符串Unicode码点排序。返回值是新的数组。 12var arr = [1, 2, 12, 'a', 'b', 'ab', 'A', 'B']arr.sort(); // [1, 12, 2, "A", "B", "a", "ab", "b"] 注意：12排在了2的前面 5.2 如果元素都是数字，要按从小到大排序，可以传入一个回调函数作为参数。 123456var arr = [1, 2, 12, 100]arr.sort(function(a,b)&#123; return a-b;&#125;);// [1, 2, 12, 100] 5.3 如果想要从大到小排序： 1234arr.sort(function(a,b)&#123; return b-a;&#125;);// [100, 12, 2, 1] 6.reverse(): 颠倒数组中元素的位置 123var arr = [1, 2, 12, 'a', 'b', 'ab', 'A', 'B'];arr.reverse();// ["B", "A", "ab", "b", "a", 12, 2, 1] 7.splice(): 修改数组元素（新增、删减、替换）。从指定的索引开始删除若干个元素，然后再从该位置添加若干个元素。返回值是删除的元素组成的数组。参数1是删除元素的起始索引，参数2是删除的元素个数，之后的参数为待添加的元素。 7.1 只删除,不添加。可以传入2个参数： 12345var arr = ['Alibaba', 'Tencent', 'Baidu', 'XiaoMi', '360'];// 从索引2开始删除3个元素arr.splice(2, 3); // 返回删除的元素 ['Baidu', 'XiaoMi', '360']arr; // ['Alibaba', 'Tencent'] 7.2 只添加,不删除。第2个参数设为0，即不删除元素。 12arr.splice(2, 0, 'Toutiao', 'Meituan', 'Didi'); // 返回[],因为没有删除任何元素arr; // ["Alibaba", "Tencent", "Toutiao", "Meituan", "Didi"] 7.3 先删除若干元素，然后在删除的位置上在添加若干个元素。 123var arr =["Alibaba", "Tencent", "Toutiao", "Meituan", "Didi"]arr.splice(2,2,'Apple','Google'); // ["Toutiao", "Meituan"]arr; // ["Alibaba", "Tencent", "Apple", "Google", "Didi"] Array.isArray()用来判断一个值是否为数组, 如果参数为数组，返回true，否则，返回false. 1234var arr = [1,2]Array.isArray(arr); // true;Array.isArray('a'); // false]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中字符串对象常用方法]]></title>
    <url>%2F2019%2F07%2F18%2FJavaScript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Strong对象用于处理字符串，但作为在前端路上爬行的小鸟时常会忘记一些方法，写这篇文章的主要目的是可以方便查看和增加记忆。 数字转转字符串的方法:123let number=0; // 数字类型console.log(String(number)) // '0' 字符串console.log(new String(number)) // [String: '0'] 对象形式 静态 String.fromCharCode() 方法返回使用指定的Unicode值序 列创建的字符串。1console.log(String.fromCharCode(65,66,67)) // 'ABC' String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串。1String.fromCodePoint(65, 90); // "AZ" charAt() 方法从一个字符串中返回指定的字符。1console.log('hello'.charAt(3)) // 'l' charCodeAt() 查找字符串下标并返回unicode 值序1console.log("ABC".charCodeAt(0)) // returns 65 codePointAt() 方法返回 一个 Unicode 编码点值的非负整数。1console.log("ABC".codePointAt(0)) // returns 65 concat()方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。12let hello = 'hello';console.log(hello.concat(' word','!')); // 'hello word!'' endsWith()判断字符串结尾是否以指定的字符串结尾123456endsWith(searchString,position)searchString 为制定的字符串position 搜索截止的下标，没有填写即为字符串lengthlet str = "To be, or not to be, that is the question.";console.log( str.endsWith("question.") ); // trueconsole.log( str.endsWith("to be") ); // false includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。12console.log('Blue Whale'.includes('blue')); // false 区分大小写console.log('Blue Whale'.includes('Blue')); // true indexOf(searchValue,fromIndex) //在字符串中查找searchValue第一次出现的index，fromIndex默认为0，开始搜索的位置12console.log("Blue Whale".indexOf("Whale", 5)); // 5console.log("Blue Whale".indexOf("Whale", 12)); // -1 lastIndexOf(searchValue,fromIndex) 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -112console.log("canal".lastIndexOf("a")) // returns 3console.log("canal".lastIndexOf("a",7)) // returns 3 match() 当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。123456789var match = 'For more information, see Chapter 3.4.5.1';var re = /see (chapter \d+(\.\d)*)/i;var found = match.match(re);console.log(found); // [ 'see Chapter 3.4.5.1',// 'Chapter 3.4.5.1',// '.1',// index: 22,// input: 'For more information, see Chapter 3.4.5.1' ] es6 padEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。123console.log('abc'.padEnd(10)); // "abc " 长度为10'abc'.padEnd(10, "foo"); // "abcfoofoof" //长度为10'abc'.padEnd(6, "123456"); // "abc123" 长度为6 es6 padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。123'abc'.padStart(10); // " abc" 长度为10'abc'.padStart(10, "foo"); // "foofoofabc"'abc'.padStart(6,"123465"); // "123abc" repeat()构建并返回一个新字符串，123console.log('abcd'.repeat(2)); // abcdabcdconsole.log('abcd'.repeat(0)); // ''console.log('abcd'.repeat(3.5)); // abcdabcdabcd 小数会进行一个求余转整数 replace() 匹配元素替换1console.log('hi word'.replace('hi','hello')) // hello word search() 方法执行正则表达式和 String对象之间的一个搜索匹配。1console.log('abc'.search('b')) // 下标为1 slice(beginSlice，endSlice) 方法提取一个字符串的一部分，并返回新的字符串1console.log('abc'.slice(1,3)) // bc split();把字符串根据符号改为数组1console.log('hello word'.split('')); // [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'd' ] es6 startsWith(searchString，position) 判断字符串开始是否以指定字符串12345searchString 指定字符串position 开始的位置 默认为0let sWith='To be, or not to be, that is the question.';console.log(sWith.startsWith('To')) //trueconsole.log(sWith.startsWith('to')) //false substr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。1console.log('hello word'.substr(1,2)) // el substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。123var anyString = "Mozilla";console.log(anyString.substring(0,3)); // Mozconsole.log(anyString.substring(3,0)); // Moz toLocaleLowerCase() 字符串转换为小写1console.log('ALPHABET'.toLocaleLowerCase()); // alphabet toLocaleUpperCase() 字符串转换为大小写1console.log('alphabet'.toLocaleUpperCase()); // ALPHABET toLowerCase() 转换为小写1console.log('ALPHABET'.toLowerCase()); // alphabet toUpperCase()转换为大写1console.log('alphabet'.toUpperCase()) // ALPHABET trim()去除字符串两边的空格1console.log(' hello '.trim()); // hello valueOf() 返回一个string对象 的原始值123let string=new String('hello word');console.log(string); // [String: 'hello word']console.log(string.valueOf()); // hello word raw() 是一个模板字符串的标签函数12let name='xiaozhang';console.log(String.raw`hello $&#123;name&#125;`); // hello xiaozhang 常用的转义符号12345678910111213\0 空字符\' 单引号\" 双引号\\ 反斜杠\n 换行\r 回车\v 垂直制表符\t 水平制表符\b 退格\f 换页\uXXXX unicode 码\u&#123;X&#125; ... \u&#123;XXXXXX&#125; unicode codepoint \xXX Latin-1 字符(x小写)]]></content>
  </entry>
  <entry>
    <title><![CDATA[var、let和const的区别]]></title>
    <url>%2F2019%2F07%2F15%2Fvar%E3%80%81let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着ES6规范的到来，JavaScript中定义变量的方法已经由单一的 var 方式发展到了 var、let、const 三种之多，var众所周知，可那俩新来的哥们到底有啥新特性？到底该啥时用？ var存在的两个bug1.js没有块级作用域 通过 var 声明的变量，其作用域是函数的全部 2.循环内变量会过度共享 在循环内部定义的变量，在循环外部依旧可以访问 let存在的意义1.let声明的变量拥有块级作用域 let声明的变量其作用域只是外层块，而不是外层函数 2.let声明的全局变量不是全局对象的属性 通过let声明的全局变量无法通过window.变量名进行访问，其只存在于一个相对的作用域中 3.形如 for(let x in data) 的循环在每次迭代时都会为 x 创建新的绑定 4.let声明的变量无法重新被定义 5.let变量在声明前无法被调用 这个比较基于花括号包裹的作用域中声明了变量name ，所以JS编译器会根据ES6规定的 变量在声明之前无法使用 抛出错误 var声明的变量可以被使用是因为存在 变量提升if (true) { name = ‘abc’ // name is no defined let name} if (true) { name = ‘abc’ console.log(name) // abc var name } const的作用1.const就是用于定义常量的，常量（不会改变的变量）有以下特点 声明时必须赋值 赋值后不可以改变 1如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。 区别 var 和 let 用以声明变量，const 用于声明只读的常量； var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效； let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用； let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响； let 不允许在相同作用域内，重复声明同一个变量； const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookies，sessionStorage 和 localStorage 的区别]]></title>
    <url>%2F2019%2F07%2F11%2Fcookies%EF%BC%8CsessionStorage%20%E5%92%8C%20localStorage%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[随着互联网的快速发展，基于网页的应用随之增多，同时也变得越来越复杂，为了满足不同的需求会经常在本地存储大量数据，传统方式我们会用document.cookie来进行存储，但是cookie的存储大小只有4k左右，并且解析也比较复杂，每一次发送请求都需要携带cookie这样会造成带宽的浪费，给开发者带来诸多不便。 随着HTML5的到来为这些问题带来了解决方案，web存储的诞生解决了cookie存在的各种问题，web存储是将数据存储到用户的电脑上，这样可以缓解服务器的压力同时提高体验。 webstorage webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。 localStorage 1localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。 sessionStorage 1sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API： 1234567localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。localStorage.clear();​//清空localStorage中所有信息 Cookie 1生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好。 sessionStorage 、localStorage 和 cookie 之间的区别共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。]]></content>
  </entry>
</search>
